"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateRoomMetadataRequest = exports.SendDataResponse = exports.SendDataRequest = exports.UpdateSubscriptionsResponse = exports.UpdateSubscriptionsRequest = exports.UpdateParticipantRequest = exports.ParticipantPermission = exports.MuteRoomTrackResponse = exports.MuteRoomTrackRequest = exports.RemoveParticipantResponse = exports.RoomParticipantIdentity = exports.ListParticipantsResponse = exports.ListParticipantsRequest = exports.DeleteRoomResponse = exports.DeleteRoomRequest = exports.ListRoomsResponse = exports.ListRoomsRequest = exports.CreateRoomRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const livekit_models_1 = require("./livekit_models");
exports.protobufPackage = "livekit";
const baseCreateRoomRequest = {
    name: "",
    emptyTimeout: 0,
    maxParticipants: 0,
    nodeId: "",
    metadata: "",
};
exports.CreateRoomRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.emptyTimeout !== 0) {
            writer.uint32(16).uint32(message.emptyTimeout);
        }
        if (message.maxParticipants !== 0) {
            writer.uint32(24).uint32(message.maxParticipants);
        }
        if (message.nodeId !== "") {
            writer.uint32(34).string(message.nodeId);
        }
        if (message.metadata !== "") {
            writer.uint32(42).string(message.metadata);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCreateRoomRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.emptyTimeout = reader.uint32();
                    break;
                case 3:
                    message.maxParticipants = reader.uint32();
                    break;
                case 4:
                    message.nodeId = reader.string();
                    break;
                case 5:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseCreateRoomRequest);
        if (object.name !== undefined && object.name !== null) {
            message.name = String(object.name);
        }
        else {
            message.name = "";
        }
        if (object.emptyTimeout !== undefined && object.emptyTimeout !== null) {
            message.emptyTimeout = Number(object.emptyTimeout);
        }
        else {
            message.emptyTimeout = 0;
        }
        if (object.maxParticipants !== undefined &&
            object.maxParticipants !== null) {
            message.maxParticipants = Number(object.maxParticipants);
        }
        else {
            message.maxParticipants = 0;
        }
        if (object.nodeId !== undefined && object.nodeId !== null) {
            message.nodeId = String(object.nodeId);
        }
        else {
            message.nodeId = "";
        }
        if (object.metadata !== undefined && object.metadata !== null) {
            message.metadata = String(object.metadata);
        }
        else {
            message.metadata = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.name !== undefined && (obj.name = message.name);
        message.emptyTimeout !== undefined &&
            (obj.emptyTimeout = message.emptyTimeout);
        message.maxParticipants !== undefined &&
            (obj.maxParticipants = message.maxParticipants);
        message.nodeId !== undefined && (obj.nodeId = message.nodeId);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseCreateRoomRequest);
        if (object.name !== undefined && object.name !== null) {
            message.name = object.name;
        }
        else {
            message.name = "";
        }
        if (object.emptyTimeout !== undefined && object.emptyTimeout !== null) {
            message.emptyTimeout = object.emptyTimeout;
        }
        else {
            message.emptyTimeout = 0;
        }
        if (object.maxParticipants !== undefined &&
            object.maxParticipants !== null) {
            message.maxParticipants = object.maxParticipants;
        }
        else {
            message.maxParticipants = 0;
        }
        if (object.nodeId !== undefined && object.nodeId !== null) {
            message.nodeId = object.nodeId;
        }
        else {
            message.nodeId = "";
        }
        if (object.metadata !== undefined && object.metadata !== null) {
            message.metadata = object.metadata;
        }
        else {
            message.metadata = "";
        }
        return message;
    },
};
const baseListRoomsRequest = { names: "" };
exports.ListRoomsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.names) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseListRoomsRequest);
        message.names = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.names.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseListRoomsRequest);
        message.names = [];
        if (object.names !== undefined && object.names !== null) {
            for (const e of object.names) {
                message.names.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.names) {
            obj.names = message.names.map((e) => e);
        }
        else {
            obj.names = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseListRoomsRequest);
        message.names = [];
        if (object.names !== undefined && object.names !== null) {
            for (const e of object.names) {
                message.names.push(e);
            }
        }
        return message;
    },
};
const baseListRoomsResponse = {};
exports.ListRoomsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.rooms) {
            livekit_models_1.Room.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseListRoomsResponse);
        message.rooms = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.rooms.push(livekit_models_1.Room.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseListRoomsResponse);
        message.rooms = [];
        if (object.rooms !== undefined && object.rooms !== null) {
            for (const e of object.rooms) {
                message.rooms.push(livekit_models_1.Room.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.rooms) {
            obj.rooms = message.rooms.map((e) => (e ? livekit_models_1.Room.toJSON(e) : undefined));
        }
        else {
            obj.rooms = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseListRoomsResponse);
        message.rooms = [];
        if (object.rooms !== undefined && object.rooms !== null) {
            for (const e of object.rooms) {
                message.rooms.push(livekit_models_1.Room.fromPartial(e));
            }
        }
        return message;
    },
};
const baseDeleteRoomRequest = { room: "" };
exports.DeleteRoomRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDeleteRoomRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseDeleteRoomRequest);
        if (object.room !== undefined && object.room !== null) {
            message.room = String(object.room);
        }
        else {
            message.room = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseDeleteRoomRequest);
        if (object.room !== undefined && object.room !== null) {
            message.room = object.room;
        }
        else {
            message.room = "";
        }
        return message;
    },
};
const baseDeleteRoomResponse = {};
exports.DeleteRoomResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDeleteRoomResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseDeleteRoomResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseDeleteRoomResponse);
        return message;
    },
};
const baseListParticipantsRequest = { room: "" };
exports.ListParticipantsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseListParticipantsRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseListParticipantsRequest);
        if (object.room !== undefined && object.room !== null) {
            message.room = String(object.room);
        }
        else {
            message.room = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseListParticipantsRequest);
        if (object.room !== undefined && object.room !== null) {
            message.room = object.room;
        }
        else {
            message.room = "";
        }
        return message;
    },
};
const baseListParticipantsResponse = {};
exports.ListParticipantsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.participants) {
            livekit_models_1.ParticipantInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseListParticipantsResponse);
        message.participants = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.participants.push(livekit_models_1.ParticipantInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseListParticipantsResponse);
        message.participants = [];
        if (object.participants !== undefined && object.participants !== null) {
            for (const e of object.participants) {
                message.participants.push(livekit_models_1.ParticipantInfo.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.participants) {
            obj.participants = message.participants.map((e) => e ? livekit_models_1.ParticipantInfo.toJSON(e) : undefined);
        }
        else {
            obj.participants = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseListParticipantsResponse);
        message.participants = [];
        if (object.participants !== undefined && object.participants !== null) {
            for (const e of object.participants) {
                message.participants.push(livekit_models_1.ParticipantInfo.fromPartial(e));
            }
        }
        return message;
    },
};
const baseRoomParticipantIdentity = { room: "", identity: "" };
exports.RoomParticipantIdentity = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRoomParticipantIdentity);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseRoomParticipantIdentity);
        if (object.room !== undefined && object.room !== null) {
            message.room = String(object.room);
        }
        else {
            message.room = "";
        }
        if (object.identity !== undefined && object.identity !== null) {
            message.identity = String(object.identity);
        }
        else {
            message.identity = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.identity !== undefined && (obj.identity = message.identity);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseRoomParticipantIdentity);
        if (object.room !== undefined && object.room !== null) {
            message.room = object.room;
        }
        else {
            message.room = "";
        }
        if (object.identity !== undefined && object.identity !== null) {
            message.identity = object.identity;
        }
        else {
            message.identity = "";
        }
        return message;
    },
};
const baseRemoveParticipantResponse = {};
exports.RemoveParticipantResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRemoveParticipantResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseRemoveParticipantResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseRemoveParticipantResponse);
        return message;
    },
};
const baseMuteRoomTrackRequest = {
    room: "",
    identity: "",
    trackSid: "",
    muted: false,
};
exports.MuteRoomTrackRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        if (message.trackSid !== "") {
            writer.uint32(26).string(message.trackSid);
        }
        if (message.muted === true) {
            writer.uint32(32).bool(message.muted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMuteRoomTrackRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                case 3:
                    message.trackSid = reader.string();
                    break;
                case 4:
                    message.muted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMuteRoomTrackRequest);
        if (object.room !== undefined && object.room !== null) {
            message.room = String(object.room);
        }
        else {
            message.room = "";
        }
        if (object.identity !== undefined && object.identity !== null) {
            message.identity = String(object.identity);
        }
        else {
            message.identity = "";
        }
        if (object.trackSid !== undefined && object.trackSid !== null) {
            message.trackSid = String(object.trackSid);
        }
        else {
            message.trackSid = "";
        }
        if (object.muted !== undefined && object.muted !== null) {
            message.muted = Boolean(object.muted);
        }
        else {
            message.muted = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.identity !== undefined && (obj.identity = message.identity);
        message.trackSid !== undefined && (obj.trackSid = message.trackSid);
        message.muted !== undefined && (obj.muted = message.muted);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMuteRoomTrackRequest);
        if (object.room !== undefined && object.room !== null) {
            message.room = object.room;
        }
        else {
            message.room = "";
        }
        if (object.identity !== undefined && object.identity !== null) {
            message.identity = object.identity;
        }
        else {
            message.identity = "";
        }
        if (object.trackSid !== undefined && object.trackSid !== null) {
            message.trackSid = object.trackSid;
        }
        else {
            message.trackSid = "";
        }
        if (object.muted !== undefined && object.muted !== null) {
            message.muted = object.muted;
        }
        else {
            message.muted = false;
        }
        return message;
    },
};
const baseMuteRoomTrackResponse = {};
exports.MuteRoomTrackResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.track !== undefined) {
            livekit_models_1.TrackInfo.encode(message.track, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMuteRoomTrackResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.track = livekit_models_1.TrackInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMuteRoomTrackResponse);
        if (object.track !== undefined && object.track !== null) {
            message.track = livekit_models_1.TrackInfo.fromJSON(object.track);
        }
        else {
            message.track = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.track !== undefined &&
            (obj.track = message.track ? livekit_models_1.TrackInfo.toJSON(message.track) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMuteRoomTrackResponse);
        if (object.track !== undefined && object.track !== null) {
            message.track = livekit_models_1.TrackInfo.fromPartial(object.track);
        }
        else {
            message.track = undefined;
        }
        return message;
    },
};
const baseParticipantPermission = {
    canSubscribe: false,
    canPublish: false,
    canPublishData: false,
};
exports.ParticipantPermission = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.canSubscribe === true) {
            writer.uint32(8).bool(message.canSubscribe);
        }
        if (message.canPublish === true) {
            writer.uint32(16).bool(message.canPublish);
        }
        if (message.canPublishData === true) {
            writer.uint32(24).bool(message.canPublishData);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseParticipantPermission);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.canSubscribe = reader.bool();
                    break;
                case 2:
                    message.canPublish = reader.bool();
                    break;
                case 3:
                    message.canPublishData = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseParticipantPermission);
        if (object.canSubscribe !== undefined && object.canSubscribe !== null) {
            message.canSubscribe = Boolean(object.canSubscribe);
        }
        else {
            message.canSubscribe = false;
        }
        if (object.canPublish !== undefined && object.canPublish !== null) {
            message.canPublish = Boolean(object.canPublish);
        }
        else {
            message.canPublish = false;
        }
        if (object.canPublishData !== undefined && object.canPublishData !== null) {
            message.canPublishData = Boolean(object.canPublishData);
        }
        else {
            message.canPublishData = false;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.canSubscribe !== undefined &&
            (obj.canSubscribe = message.canSubscribe);
        message.canPublish !== undefined && (obj.canPublish = message.canPublish);
        message.canPublishData !== undefined &&
            (obj.canPublishData = message.canPublishData);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseParticipantPermission);
        if (object.canSubscribe !== undefined && object.canSubscribe !== null) {
            message.canSubscribe = object.canSubscribe;
        }
        else {
            message.canSubscribe = false;
        }
        if (object.canPublish !== undefined && object.canPublish !== null) {
            message.canPublish = object.canPublish;
        }
        else {
            message.canPublish = false;
        }
        if (object.canPublishData !== undefined && object.canPublishData !== null) {
            message.canPublishData = object.canPublishData;
        }
        else {
            message.canPublishData = false;
        }
        return message;
    },
};
const baseUpdateParticipantRequest = {
    room: "",
    identity: "",
    metadata: "",
};
exports.UpdateParticipantRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        if (message.metadata !== "") {
            writer.uint32(26).string(message.metadata);
        }
        if (message.permission !== undefined) {
            exports.ParticipantPermission.encode(message.permission, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateParticipantRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                case 3:
                    message.metadata = reader.string();
                    break;
                case 4:
                    message.permission = exports.ParticipantPermission.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUpdateParticipantRequest);
        if (object.room !== undefined && object.room !== null) {
            message.room = String(object.room);
        }
        else {
            message.room = "";
        }
        if (object.identity !== undefined && object.identity !== null) {
            message.identity = String(object.identity);
        }
        else {
            message.identity = "";
        }
        if (object.metadata !== undefined && object.metadata !== null) {
            message.metadata = String(object.metadata);
        }
        else {
            message.metadata = "";
        }
        if (object.permission !== undefined && object.permission !== null) {
            message.permission = exports.ParticipantPermission.fromJSON(object.permission);
        }
        else {
            message.permission = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.identity !== undefined && (obj.identity = message.identity);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        message.permission !== undefined &&
            (obj.permission = message.permission
                ? exports.ParticipantPermission.toJSON(message.permission)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseUpdateParticipantRequest);
        if (object.room !== undefined && object.room !== null) {
            message.room = object.room;
        }
        else {
            message.room = "";
        }
        if (object.identity !== undefined && object.identity !== null) {
            message.identity = object.identity;
        }
        else {
            message.identity = "";
        }
        if (object.metadata !== undefined && object.metadata !== null) {
            message.metadata = object.metadata;
        }
        else {
            message.metadata = "";
        }
        if (object.permission !== undefined && object.permission !== null) {
            message.permission = exports.ParticipantPermission.fromPartial(object.permission);
        }
        else {
            message.permission = undefined;
        }
        return message;
    },
};
const baseUpdateSubscriptionsRequest = {
    room: "",
    identity: "",
    trackSids: "",
    subscribe: false,
};
exports.UpdateSubscriptionsRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        for (const v of message.trackSids) {
            writer.uint32(26).string(v);
        }
        if (message.subscribe === true) {
            writer.uint32(32).bool(message.subscribe);
        }
        for (const v of message.participantTracks) {
            livekit_models_1.ParticipantTracks.encode(v, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateSubscriptionsRequest);
        message.trackSids = [];
        message.participantTracks = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.identity = reader.string();
                    break;
                case 3:
                    message.trackSids.push(reader.string());
                    break;
                case 4:
                    message.subscribe = reader.bool();
                    break;
                case 5:
                    message.participantTracks.push(livekit_models_1.ParticipantTracks.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUpdateSubscriptionsRequest);
        message.trackSids = [];
        message.participantTracks = [];
        if (object.room !== undefined && object.room !== null) {
            message.room = String(object.room);
        }
        else {
            message.room = "";
        }
        if (object.identity !== undefined && object.identity !== null) {
            message.identity = String(object.identity);
        }
        else {
            message.identity = "";
        }
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(String(e));
            }
        }
        if (object.subscribe !== undefined && object.subscribe !== null) {
            message.subscribe = Boolean(object.subscribe);
        }
        else {
            message.subscribe = false;
        }
        if (object.participantTracks !== undefined &&
            object.participantTracks !== null) {
            for (const e of object.participantTracks) {
                message.participantTracks.push(livekit_models_1.ParticipantTracks.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.identity !== undefined && (obj.identity = message.identity);
        if (message.trackSids) {
            obj.trackSids = message.trackSids.map((e) => e);
        }
        else {
            obj.trackSids = [];
        }
        message.subscribe !== undefined && (obj.subscribe = message.subscribe);
        if (message.participantTracks) {
            obj.participantTracks = message.participantTracks.map((e) => e ? livekit_models_1.ParticipantTracks.toJSON(e) : undefined);
        }
        else {
            obj.participantTracks = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseUpdateSubscriptionsRequest);
        message.trackSids = [];
        message.participantTracks = [];
        if (object.room !== undefined && object.room !== null) {
            message.room = object.room;
        }
        else {
            message.room = "";
        }
        if (object.identity !== undefined && object.identity !== null) {
            message.identity = object.identity;
        }
        else {
            message.identity = "";
        }
        if (object.trackSids !== undefined && object.trackSids !== null) {
            for (const e of object.trackSids) {
                message.trackSids.push(e);
            }
        }
        if (object.subscribe !== undefined && object.subscribe !== null) {
            message.subscribe = object.subscribe;
        }
        else {
            message.subscribe = false;
        }
        if (object.participantTracks !== undefined &&
            object.participantTracks !== null) {
            for (const e of object.participantTracks) {
                message.participantTracks.push(livekit_models_1.ParticipantTracks.fromPartial(e));
            }
        }
        return message;
    },
};
const baseUpdateSubscriptionsResponse = {};
exports.UpdateSubscriptionsResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateSubscriptionsResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseUpdateSubscriptionsResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseUpdateSubscriptionsResponse);
        return message;
    },
};
const baseSendDataRequest = { room: "", kind: 0, destinationSids: "" };
exports.SendDataRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        if (message.kind !== 0) {
            writer.uint32(24).int32(message.kind);
        }
        for (const v of message.destinationSids) {
            writer.uint32(34).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSendDataRequest);
        message.destinationSids = [];
        message.data = new Uint8Array();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.data = reader.bytes();
                    break;
                case 3:
                    message.kind = reader.int32();
                    break;
                case 4:
                    message.destinationSids.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseSendDataRequest);
        message.destinationSids = [];
        message.data = new Uint8Array();
        if (object.room !== undefined && object.room !== null) {
            message.room = String(object.room);
        }
        else {
            message.room = "";
        }
        if (object.data !== undefined && object.data !== null) {
            message.data = bytesFromBase64(object.data);
        }
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = livekit_models_1.dataPacket_KindFromJSON(object.kind);
        }
        else {
            message.kind = 0;
        }
        if (object.destinationSids !== undefined &&
            object.destinationSids !== null) {
            for (const e of object.destinationSids) {
                message.destinationSids.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.data !== undefined &&
            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));
        message.kind !== undefined &&
            (obj.kind = livekit_models_1.dataPacket_KindToJSON(message.kind));
        if (message.destinationSids) {
            obj.destinationSids = message.destinationSids.map((e) => e);
        }
        else {
            obj.destinationSids = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseSendDataRequest);
        message.destinationSids = [];
        if (object.room !== undefined && object.room !== null) {
            message.room = object.room;
        }
        else {
            message.room = "";
        }
        if (object.data !== undefined && object.data !== null) {
            message.data = object.data;
        }
        else {
            message.data = new Uint8Array();
        }
        if (object.kind !== undefined && object.kind !== null) {
            message.kind = object.kind;
        }
        else {
            message.kind = 0;
        }
        if (object.destinationSids !== undefined &&
            object.destinationSids !== null) {
            for (const e of object.destinationSids) {
                message.destinationSids.push(e);
            }
        }
        return message;
    },
};
const baseSendDataResponse = {};
exports.SendDataResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSendDataResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseSendDataResponse);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseSendDataResponse);
        return message;
    },
};
const baseUpdateRoomMetadataRequest = { room: "", metadata: "" };
exports.UpdateRoomMetadataRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.room !== "") {
            writer.uint32(10).string(message.room);
        }
        if (message.metadata !== "") {
            writer.uint32(18).string(message.metadata);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateRoomMetadataRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.room = reader.string();
                    break;
                case 2:
                    message.metadata = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseUpdateRoomMetadataRequest);
        if (object.room !== undefined && object.room !== null) {
            message.room = String(object.room);
        }
        else {
            message.room = "";
        }
        if (object.metadata !== undefined && object.metadata !== null) {
            message.metadata = String(object.metadata);
        }
        else {
            message.metadata = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.room !== undefined && (obj.room = message.room);
        message.metadata !== undefined && (obj.metadata = message.metadata);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseUpdateRoomMetadataRequest);
        if (object.room !== undefined && object.room !== null) {
            message.room = object.room;
        }
        else {
            message.room = "";
        }
        if (object.metadata !== undefined && object.metadata !== null) {
            message.metadata = object.metadata;
        }
        else {
            message.metadata = "";
        }
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, "base64").toString("binary"));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, "binary").toString("base64"));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(""));
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=livekit_room.js.map